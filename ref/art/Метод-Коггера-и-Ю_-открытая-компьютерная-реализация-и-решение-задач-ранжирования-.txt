                                                Компьютерные инструменты в образовании, 2024
                                                № 4: 24–43
                                                УДК: 621.320
                                                http://cte.eltech.ru
                                                doi:10.32603/2071-2340-2024-4-24-43



                    МЕТОД КОГГЕРА И Ю:
           ОТКРЫТАЯ КОМПЬЮТЕРНАЯ РЕАЛИЗАЦИЯ
             И РЕШЕНИЕ ЗАДАЧ РАНЖИРОВАНИЯ

   Пархоменко В. А.1 , старший преподаватель, vladimir.parkhomenko@spbstu.ru,
                              orcid.org/0000-0001-7757-377X
Лазаренко А. А.1 , студент, lazarenko2.aa@edu.spbstu.ru, orcid.org/0009-0005-1029-8095
        Щукин А. В.1 , канд. техн. наук, доцент, alexander.schukin@spbstu.ru,
                              orcid.org/0000-0002-9534-824X
              1
                  Санкт-Петербургский политехнический университет Петра Великого,
                     ул. Политехническая, д. 29, 195251, Санкт-Петербург, Россия


                                           Аннотация
       Рассмотрен метод Коггера и Ю для вычисления весов и ранжирования альтерна-
       тив. На основе этого метода парных сравнений разработана система поддержки
       принятия решений с открытым исходным кодом. Представлена архитектура разрабо-
       танного приложения, проведены модульные тесты, включая примеры из публикаций
       и специально сгенерированные случаи. Пример В. В. Подиновского, иллюстриру-
       ющий некорректность метода анализа иерархий, показал, с нашей точки зрения,
       приемлемый результат методом Коггера и Ю. Эксперимент подтвердился и на новой
       оригинальной задаче, показывая близость результатов метода Коггера и Ю и теории
       важности критериев. Решена задача ранжирования алгоритмов генерации уровней
       для компьютерных игр в двухмерном пространстве.

       Ключевые слова: многокритериальные задачи принятия решений, парные сравне-
       ния, метод Коггера и Ю, теория важности критериев, DASS, СВИРЬ.

       Цитирование: Пархоменко В. А., Лазаренко А. А., Щукин А. В. Метод Коггера и Ю: от-
       крытая компьютерная реализация и решение задач ранжирования // Компьютерные
       инструменты в образовании. 2024. № 4. С. 24–43. doi:10.32603/2071-2340-2024-4-24-43

       Благодарности: Авторы статьи благодарны коллективу разработчиков СППР СВИРЬ
       под руководством профессора С. В. Микони за предоставление возможности решения
       задач в системе, а также коллективу разработчиков СППР DASS под руководством
       профессора В. В. Подиновского за размещение инсталлятора системы в свободном
       доступе.


                                         1. ВВЕДЕНИЕ

   В реальных задачах ранжирования альтернатив трудно обойтись непосредственным
сущностным сравнением или сравнением по одному критерию, и тогда прибегают ре-
шению многокритериальной задачи. В работе рассмотрены методы индивидуального
принятия решений. Оригинальные постановки по методам, базирующимся на парных


24                                   © КОМПЬЮТЕРНЫЕ ИНСТРУМЕНТЫ В ОБРАЗОВАНИИ. №4, 2024 г.
               Метод Коггера и Ю: открытая компьютерная реализация и решение задач ранжирования


сравнениях, на основе log-Чебышевского метода аппроксимации, модификаций методов
парных сравнений приведены в [1] и [2], соответственно. Обзоры по индивидуальным
методам принятия решений с подробным анализом их работы можно найти, например,
в [2–5].
    В работе рассмотрен метод Коггера и Ю [6], являющийся одной из модификаций
метода аналитической иерархии Саати [7]. Оба метода направлены на ранжирование
альтернатив на основе матриц парных сравнений. Если реализаций метода аналити-
ческой иерархии довольно много, например, бесплатная, многофункциональная СППР
Superdecisions [8], СППР с открытым исходным кодом [9], то открытых реализаций метода
Коггера и Ю найти не удалось.
    Целью работы является изучение метода Коггера и Ю для нахождения приоритетов
(весов) альтернатив, их последующего ранжирования, а также создание системы под-
держки ранжирования альтернатив на базе этого метода.
    Разработано приложение с открытым исходным кодом [10]. Эксперименты показали,
что на примере, обосновывающем некорректность метода аналитической иерархии [11],
получен более корректный результат, близкий к результату теории важности критериев.
    Далее в разделе 2 изложена общая постановка задачи ранжирования объектов по
нескольким признакам. В разделе 3 подробно описывается метод Коггера и Ю. В разде-
ле 4 представлено проектирование системы ранжирования на основе метода Коггера и Ю.
В разделе 5 представлены шаги алгоритма с псевдокодом и иллюстративными примера-
ми расчета. В разделе 6 описываются классы системы ранжирования на основе метода
Коггера и Ю. В разделе 7 описывается модульное тестирование системы. В разделе 8 опи-
сывается ручное тестирование системы, включая действия по установке приложения.
    В разделе 9 сравниваются решения метода Коггера и Ю с решениями метода анализа
иерархий, метода взвешенных геометрических средних, а также log-Чебышевского ме-
тода аппроксимации [12]. В разделе 10 представлено сравнение решений метода Когге-
ра и Ю с методом анализа иерархий и теорией важности критериев [4, 11]. В разделе 11
представлено решение задачи ранжирования алгоритмов генерации уровней для ком-
пьютерных игр в двухмерном пространстве методом Коггера и Ю, рассчитанным в разра-
ботанной системе, методом аналитической иерархии, рассчитанным в СППР СВИРЬ [13–
15], а также методом теории важности критериев, рассчитанным в СППР DASS [16–18].

                2. ПРОБЛЕМА РАНЖИРОВАНИЯ ОБЪЕКТОВ ПО ВАЖНОСТИ

      Пусть дано конечное множество объектов (признаков или альтернатив) G =
©                       ª
 g 1 , g 2 , . . . , g n , и необходимо построить вектор w = (w 1 , w 2 , . . . , w n ) с неотрицательными
компонентами w i такими, что n
                                          P
                                            i =1 w i = 1.
      Числа w i можно интерпретировать как весовые коэффициенты, определяющие важ-
ность объектов g i . Основным объектом исследования в рассматриваемом методе являет-
ся матрица парных сравнений. Элементы данной матрицы интерпретируются как зна-
чения коэффициента превосходства одного объекта над другим. Если получается число
больше единицы, то первый объект превосходит второй объект.
    Предполагается, что лицо, принимающее решения (далее — ЛПР), имеет возможность
отвечать на вопросы типа «Во сколько раз объект g i превосходит объект g j по важно-
сти?».
    Коэффициенты МПС могут выбираться ½ из различных шкал, например, метод¾    Саати
                                                  1 1 1 1 1 1 1 1
использует следующую бальную шкалу:                , , , , , , , , 1, 2, 3, 4, 5, 6, 7, 8, 9 .
                                                  9 8 7 6 5 4 3 2

АЛГОРИТМИЧЕСКАЯ МАТЕМАТИКА И МАТЕМАТИЧЕСКОЕ МОДЕЛИРОВАНИЕ                                              25
Пархоменко В. А., Лазаренко А. А., Щукин А. В.


  Для упрощения работы пользователя можно интерпретировать значения шкалы с по-
мощью целых чисел или вербальных оценок.


                                      3. ОПИСАНИЕ МЕТОДА КОГГЕРА И Ю

   В отличие от метода Саати [7], в методе Коггера и Ю [6] используется треугольная мат-
рица парных сравнений (отсутствует сторона с подкреплением ответов лица, принима-
ющего решение, то есть значения ниже главной диагонали). Сначала находится диаго-
нальная делящая матрица:
                                                                                                                          
                                                           n                        0   0                                0
                                                          0                      n −1 0                                 0
                                                  D n×n =                                                                 .
                                                                                                                          
                                                          0                        0  ...                               0
                                                            0                       0   0                                1
                                                                                −1
    В последствии данная матрица обращается и в результате получается матрица D n×n ,
в которой ненулевые i -ые элементы образуются делением единицы на значение из ячей-
ки исходной матрицы D n×n с тем же самым i -ым индексом. В методе Коггера и Ю мо-
гут использоваться матрицы парных сравнений кратности предпочтения, которая имеет
следующий вид:
                                                                   1               s 12              s 13
                                                                                                         

                                                           S 3×3 = 0
                                                                                   1                s 23  .
                                                                   0                0                 1
   В пособии [5] и работе [19] предлагают опрашивать ЛПР n − 1 раз по шкале кратности
предпочтений (таблица 1).

                  Таблица 1. Шкалы предпочтений с различными степенями [1]
                                                                                                                                Сильная уступка
                                                                                    Равнозначность


                                                                                                        Слабая уступка




                                                                                                                                                   Очень сильная
                                  Очень сильное
                                  превосходство
                  превосходство




                                                  превосходство



                                                                  превосходство
                   Абсолютное




                                                                                                                                                                    Абсолютная
                                                    Сильное




                                                                                                                                                      уступка
                                                                     Слабое




                                                                                                                                                                      уступка




            ±
           p i
           1,5   5,0625           3,375            2,25             1,5               1               0,(6)                 0,(4)                 0,(296)          0,(1975)
            2        16               8               4               2               1                0,5                  0,25                   0,125           0,0625
            3        81              27               9               3               1               0,(3)                 0,(1)                 0,0(370)         0,(0..9)


   Это необходимо для того, чтобы избежать противоречий в показаниях ЛПР. Осталь-
ные показатели рассчитываются с помощью сверхтранзитивности:

                                                                  si k = si j · s j k .                                                                                          (1)

   Пусть s 12 , s 23 в формуле 1 — это ответы ЛПР, тогда s 13 выводится автоматически по за-
мыканию. Оценки всегда располагаются выше главной диагонали. Для избежания оши-
бок во время работы алгоритма матрица парных сравнений заполняется снизу вверх. Сле-
дующим шагом идет подсчет суммы каждой строки матрицы D −1 S для создания вектора
сумм:


26                                                       © КОМПЬЮТЕРНЫЕ ИНСТРУМЕНТЫ В ОБРАЗОВАНИИ. №4, 2024 г.
            Метод Коггера и Ю: открытая компьютерная реализация и решение задач ранжирования



                                         Pn         
                                           i =1 s 1i
                                         Pn s 
                                          i =2 2i 
                                     a =  ... .
                                                    
                                         Pn
                                          i=j s ji 
                                                     

                                                1
   В результате с помощью двух матриц и одного вектора можно найти вес каждого объ-
екта:
                                       D −1 Sa = w.                                      (2)
     Вектор весов w имеет такую же размерность, как и вектор сумм a . Данный вектор
все еще не готов к использованию, так как его необходимо нормализовать, полагая
Pn
  i =1 w i = 1. Для достижения такого результата можно рассмотреть вспомогательные
формулы (3) и (4), где |w| во второй формуле — мощность множества (размер вектора),
а значение «2» означает, что для нормализации необходимо минимум 2 числа (при
меньшем количестве эта операция не имеет смысла).

                                             wi
                                      ωi = Pn                                            (3)
                                              j =1 w j

                                           wi            |w| − 2
                                ωi = 1 − Pn          −                                   (4)
                                          j =1 w j         |w|

   Формулы (3) и (4) используются, когда необходимо нормализовать значения, подлежа-
щие максимизации (чем больше, тем лучше) или минимизации (чем меньше, тем луч-
ше), соответственно.
   Когда веса признаков w и веса альтернатив ωi по каждому признаку i рассчитаны,
можно оценить альтернативы c помощью

                                   ev al uat i on = ωw,                                  (5)
где ω — матрица весов альтернатив, составленная из последовательных ωi .
    Далее спроектируем систему, позволяющую ранжировать альтернативы на основе
метода Коггера и Ю.


  4. ПРОЕКТИРОВАНИЕ АРХИТЕКТУРЫ СИСТЕМЫ ПОДДЕРЖКИ РАНЖИРОВАНИЯ
               АЛЬТЕРНАТИВ НА ОСНОВЕ МЕТОДА КОГГЕРА И Ю

   На рис. 1 представлена общая схема работы программы в нотации Archimate [20].
   При запуске программы пользователь попадает в основной цикл (Main loop), в кото-
ром он может выбирать действия с помощью ввода с клавиатуры.
   В настройках (Settings) пользователь может выбрать отображение дополнительной
информации (Additional info) для просмотра МПС, способ оценивания (для сравнения ре-
ализован метод простого выбора из пособия [5] для сравнения с методом Коггера и Ю),
основание предпочтения (Preference base, таблица 1).
   Диалоговая система задает вопросы ЛПР и по его ответам оценивает приоритет аль-
тернатив.
   Для реализации указанного в подразделе функционала выбран язык общего назна-
чения Java. Систему решено реализовать в виде консольного приложения. Алгоритмиче-
ское проектирование метода Коггера и Ю представлено в следующем разделе.


АЛГОРИТМИЧЕСКАЯ МАТЕМАТИКА И МАТЕМАТИЧЕСКОЕ МОДЕЛИРОВАНИЕ                                27
Пархоменко В. А., Лазаренко А. А., Щукин А. В.




                 Рис. 1. Схема работы программы c реализацией метода Коггера и Ю



                  5. МЕТОД КОГГЕРА И Ю НА АЛГОРИТМИЧЕСКОМ УРОВНЕ

   После того, как пользователь импортировал таблицу csv или txt формата, ему задают
вопросы о значимости признаков по следующему алгоритму:

       Алгоритм формирования матрицы значимости признаков
         Вход: массив признаков таблицы M .
         Выход: матрица парных сравнений S .
     1.  цикл с i ← 0 до i ≤ |M |, выполнять
     2.     цикл с j ← i до j ≥ 0, выполнять
     3.        если j == i тогда
     4.           s j i ← 1;
     5.        иначе
     6.           если j == (i − 1) тогда
     7.                 bu f f ← ввод целого числа;
     8.                  s j i ← p −bu f f +5 ;
     9.             иначе
  10.                 s j i ← s j ,i −1 · s j +1,i ;
 11.          j ← j − 1;
 12.       i ← i + 1;

   С помощью данного фрагмента кода в матрице задаются значения признаков: на диа-
гонали 1, по соседству выше введенные пользователем значения, причем p −x+5 необхо-
димо для приведения ответа к шкале предпочтений, остальные значения вычисляются
транзитивно.
     Рассмотрим пример: пользователь ввел для таблицы с четырьмя признаками ответы
{3, 5, 7}, основание шкалы превосходства p = 2, тогда матрица парных сравнений строится
следующим образом:


28                                                © КОМПЬЮТЕРНЫЕ ИНСТРУМЕНТЫ В ОБРАЗОВАНИИ. №4, 2024 г.
               Метод Коггера и Ю: открытая компьютерная реализация и решение задач ранжирования

                                                                                  
                 1 − − −     1 2−3+5                  −       −       1     4   4   1
               0 1 − − 0      1                  2−5+5     −  0
                                                                          1   1 0, 25
                         →                                      →                  .
                                                                                    
               0 0 1 − 0      0                    1     2−7+5  0      0   1 0, 25
               
                 0 0 0 1     0   0                    0       1       0     0   0   1

    Далее происходит умножение делящей матрицы D −1 на матрицу парных сравнений
S. Это можно реализовать с помощью деления в следующем алгоритме:

    Алгоритм произведения делящей матрицы на матрицу парных сравнений
      Вход: матрица парных сравнений S .
      Выход: матрица парных сравнений D −1 S .
  1.  цикл с i ← 0 до i < S.r ow s, выполнять
  2.     цикл с j ← i до j < S.col s , выполнять
                          si j
  3.          s i j ← S.r ow s−1 ;
  4.          j ← j + 1;
  5.       i ← i + 1;

      В контексте рассматриваемого примера происходит деление каждой строки матри-
цы:
                                             ¯                               
                           1     4    4   1 ¯¯: 4       0, 25   1     1   0, 25
                         0      1    1 0, 25¯¯ : 3 
                                                      0     0, 33 0, 33 0, 08
                                                      
                                              ¯ →                             .
                                                                               
                         0      0    1 0, 25¯ : 2   0        0    0, 5 0, 13
                         
                                              ¯
                           0     0    0   1 ¯: 1          0     0     0     1

  После этого рассчитывается сумма каждой строки и превращается в вектор следую-
щим образом:

    Алгоритм вычисления вектора сумм a
      Вход: матрица парных сравнений D −1 S .
      Выход: вектор сумм a .
  1.  цикл с i ← 0 до i < DS.r ow s, выполнять
  2.     цикл с j ← i до j < DS.col s , выполнять
  3.        ai ← ai + si j ;
  4.        j ← j + 1;
  5.       i ← i + 1;

      Для рассматриваемого случая расчет вектора сумм представлен в преобразовании:
                                                                    
                                      0, 25   1     1   0, 25     2, 5
                                      0    0, 33 0, 33 0, 08 0, 74
                                                                      
                                                              →      .
                                     
                                      0      0    0, 5 0, 13 0, 63
                                     
                                        0     0     0     1        1

   После этого матрица D −1 S умножается на вектор a, после чего получаются весовые
коэффициенты w, в контексте примера следующим образом:
                                                                    
                              0, 25   1     1   0, 25     2, 5    2, 245
                              0    0, 33 0, 33 0, 08 0, 74 0, 532
                                                                      
                                                      ×      =       .
                             
                              0      0    0, 5 0, 13 0, 63 0, 445
                             
                                0     0     0     1        1         1



АЛГОРИТМИЧЕСКАЯ МАТЕМАТИКА И МАТЕМАТИЧЕСКОЕ МОДЕЛИРОВАНИЕ                                   29
Пархоменко В. А., Лазаренко А. А., Щукин А. В.


  После этого веса проходят нормализацию. Процесс нормализации представлен следу-
ющим образом:

       Алгоритм нормализации вектора весов
         Вход: вектор весов w .
         Выход: нормализованный вектор весов ω.
     1.  цикл с i ← 0 до i < |w|, выполнять
     2.     sum ← sum + w i ;
     3.     i ← i + 1;
     4.   цикл с i ← 0 до i < |w|, выполнять
     5.     ωi ← sum + w i ;
     6.     i ← i + 1;

   В рассматриваемом примере, получение нормализованного вектора весов признаков
представлено преобразованием
                                                             
                                              2, 245      0, 53
                                            0, 532    0, 13
                                                      →       .
                                                             
                                            0, 445     0, 1 
                                            
                                                 1        0, 24

   Аналогичным образом рассчитываются веса альтернатив по каждому признаку. Од-
нако стоит учитывать, что при импорте таблиц значения признаков могут быть заданы
не по транзитивной шкале. В таком случае сверхтранзитивная связь будет выполняться
только для каждых трех элементов. Тогда можно использовать алгоритм, отраженный
далее:

       Алгоритм создания МПС при отсутствии транзитивности
         Вход: массив значений признака m k .
         Выход: матрица парных сравнений S k по признаку m k .
     1.  цикл с i ← 0 до i < |m k |, выполнять
     2.     цикл с j ← i до j < |m k |, выполнять
                      mi k
     3.        si j ← mjk
                           ;
     4.        j ← j + 1;
     5.     i ← i + 1;

   Пример. Пусть признак b имеет значения {65, 95, 105, 170}. Видно, что между соседни-
ми величинами разное относительное расстояние. В таком случае создается МПС, пред-
ставленная результатом преобразования (6).
                                 65    65        65
                                                                             
                             1   95   105       170       1   0, 68 0, 62 0, 38
                            0         95        95 
                                 1    105       170 
                                                        0      1   0, 9 0, 56
                                                105  →                                  (6)
                                                                              
                            0   0    1                 0      0     1   0, 62
                                                                               
                                                170
                                                    
                             0   0    0         1           0   0     0     1

   Если же попробовать посчитать МПС по первому алгоритму, то в транзитивности
между элементами 65 и 170 возникнет ошибка, приведем расчет на примере (7).
                                 65
                                                                           
                             1   95   −          −        1 0, 68 0, 62 0, 35
                            0         95
                                 1    105        −  0
                                                             1   0, 9 0, 56
                                                      →                                   (7)
                                                                             
                                                105
                            0   0    1              0      0     1   0, 62
                                                                           
                                                170
                             0   0    0          1        0   0     0     1

30                                      © КОМПЬЮТЕРНЫЕ ИНСТРУМЕНТЫ В ОБРАЗОВАНИИ. №4, 2024 г.
            Метод Коггера и Ю: открытая компьютерная реализация и решение задач ранжирования


   Между (7) и (6) видно несоответствие между числами 0,38 и 0,35.
   В силу этих причин авторы статьи рекомендуют импортировать таблицы после пред-
варительной проверки сверхтранзитивности, вводить данные в систему вручную (с уче-
том верификации противоречий системой) или комбинировать оба алгоритма, напри-
мер, чтобы исследовать противоречия в рассуждениях. В следующем разделе приведено
проектирование классов приложения.


   6. ПРОЕКТИРОВАНИЕ КЛАССОВ СИСТЕМЫ ПОДДЕРЖКИ ПРИНЯТИЯ РЕШЕНИЙ

   Программа состоит из трех основных классов: Application, csvReader и ranker.
   Класс Application запускает основной цикл и предоставляет возможность ввода для
выбора действия. Пользователь может выбрать импорт таблицы, настройки и выход.
   Настройки позволяют выбрать основание предпочтения (таблица 1), отображение до-
полнительной информации (МПС), и способ расчета оценки.
   При выборе импорта таблицы пользователь вводит путь к файлу, после чего
CSVReader читает файл и возвращает двумерный массив класса Object. Данный массив
разделяется на массив признаков и двумерный массив альтернатив со значениями по
каждому признаку. Эти данные передаются в класс Ranker.
   Ranker проводит опрос пользователя по важности признаков и их направлении оп-
тимизации.
   Предполагается работа с тремя векторами: head, optimization, attributeAnswers, и одна
матрица: data, которые переходят в методы SimpleRankObjects или CoggerYuRankObjects.
Выбор метода зависит от выбранной настройки (по умолчанию задан CoggerYuRankObjects).
   Открытая реализация программы приведена по ссылке [10]. Далее перейдем к крат-
кому описанию функционального тестирования программы.


                   7. МОДУЛЬНОЕ ТЕСТИРОВАНИЕ ПРОГРАММЫ

   Для того чтобы проверить корректность работы приложения, были сформированы
тестовые сценарии. Для реализации тестовых сценариев выбраны модульные тесты.
   Проверяются следующие модули системы:
  —   произведение делящей матрицы на матрицу парных сравнений;
  —   нахождение вектора сумм;
  —   нахождение весов объектов (признаков или альтернатив);
  —   нормализация весов.
   В тестах проверяется сходство полученных значений с ожидаемыми в окрестности
ε = 0, 001 (погрешность расчета). В таблице 2 представлены входные данные и ожидаемые
значения.
   Для тестирования используется фреймворк JUnit. Он позволяет разработчикам пи-
сать и запускать тесты для проверки правильности работы отдельных модулей (классов,
методов) в их коде. JUnit предоставляет аннотации, такие как @Test, @Before, @After
и другие, которые упрощают процесс написания тестов и организацию тестового кода.
   Разработанные модульные тесты показывают, что результат расчета системы совпа-
дает с ожидаемым выходом, следовательно, есть доля уверенности, что расчеты в прило-
жении производятся верно. Однако перед коммерческим использованием авторы реко-
мендуют дополнительно использовать другие техники тестирования, такие как фаззинг,


АЛГОРИТМИЧЕСКАЯ МАТЕМАТИКА И МАТЕМАТИЧЕСКОЕ МОДЕЛИРОВАНИЕ                                31
Пархоменко В. А., Лазаренко А. А., Щукин А. В.


                           Таблица 2. Описание контрольных примеров


              Тестируемый метод                Входные данные                              Ожидаемый результат
                                                                                                                 
                                                                                               1            3      7
                                             1         4        3       7                               1
                                                                                            4            4      4
                                            0                  1                                       1   1
                                  −1
                                                       1        3       3                    0
                                                                                                        3   9      1
              Произведение D           S                                   [12]
                                                                                                                  
                                                                                                            1      5
                                                                                                                   
                                            0         0        1       5                    0        0
                                                                                                         2      2
                                                0      0        0       1                         0     0   0      1
                                                                                                         
                                                  1                 3           7                         15
                                                           1
                                                 4                 4           4                      4
                                                 0         1       1                                    13 
                                                            3       9       1                          9
              Расчет вектора сумм
                                                                             
                                                                    1       5
                                                                                                       
                                                 0        0                                            3
                                                                   2       2                           
                                                   0       0        0       1                            1
                                                                                                          
                                            1                  3    7             15
                                                     1                                                 6, 3819
                                           4                  4    4          4                           
                                           0        1         1                 13 
                                                     3         9    1          9
                                                                                                      1, 8148
                  Расчет весов                                        ,  
                                                                                                            
                                                               1    5  
                                                                                                             
                                           0        0              2  3 
                                                                                                       4 
                                                              2                                              
                                             0       0         0    1     1                                1
                                                                                                            
                                                           6, 3819                                     0, 4835
                                                                                                            
                                                       1, 8148                                      0, 1375
                    Расчет ω
                                                                                                            
                                                                                                            
                                                        4                                           0, 3031
                                                                                                            
                                                            1                                          0, 0757



промышленные статические анализаторы и др. Тесты помещены в том же открытом ре-
позитории, что и реализованное приложение [10].
   Далее перейдем к описанию ручного тестирования программы.


                          8. РУЧНОЕ ТЕСТИРОВАНИЕ ПРОГРАММЫ

    Для начала работы с приложением необходимо скачать [10] и разархивировать при-
ложение. Самым простым способом является использование среды разработки IntelliJ
IDEA. Проект запускается из класса MCD.Main.java.
    Альтернативным способом сборки является установка Maven в проект. В таком слу-
чае необходимо будет вручную составить pom.xml. То же самое можно сделать с помо-
щью Gradle. Для этого необходимо удалить CoggerYu.iml, после чего инициализировать
build.gradle.
    Для работы необходимо импортировать таблицу вида (таблица 3).

                                 Таблица 3. Вид импортируемых данных


                       Признак 1               Признак 2                             ...      Признак N
                      Значение11               Значение12                            ...     Значение1N
                           ...                           ...                         ...              ...
                      ЗначениеM 1           ЗначениеM 2                              ...     ЗначениеM N



32                                         © КОМПЬЮТЕРНЫЕ ИНСТРУМЕНТЫ В ОБРАЗОВАНИИ. №4, 2024 г.
            Метод Коггера и Ю: открытая компьютерная реализация и решение задач ранжирования


   Важно, чтобы в названии признаков не было пробелов, также важно, чтобы все зна-
чения признаков были численными.
   Для общения с диалоговой системой пользователь вводит числа, почти перед каж-
дым вопросом пользователю показывается меню, чтобы можно было понять, какой спи-
сок действий доступен.
   Для начала вычислений пользователю необходимо импортировать файл расшире-
ния csv или txt, в которых присутствует заглавная строка, в качестве разделителей ис-
пользуется «,», а сами значения являются числовыми.
   После импорта таблицы пользователь отвечает на вопросы о том, какие признаки
для него наиболее важны и какие наименее важны. Также у пользователя спрашивают
направление оптимизации для каждого признака. После происходит расчет всех значе-
ний, и пользователь получает оценку для каждой альтернативы. На рисунке 2 представ-
лен пример работы с системой.




                       Рис. 2. Пример работы с диалоговой системой


   Далее перейдем к решению прикладных задач методом Коггера и Ю и сравнению ре-
зультатов с другими методами парных сравнений.


АЛГОРИТМИЧЕСКАЯ МАТЕМАТИКА И МАТЕМАТИЧЕСКОЕ МОДЕЛИРОВАНИЕ                                33
Пархоменко В. А., Лазаренко А. А., Щукин А. В.


                 9. СРАВНЕНИЕ РЕЗУЛЬТАТОВ МЕТОДА КОГГЕРА И Ю
            С РЕШЕНИЕМ МАИ, СРЕДНЕГО ГЕОМЕТРИЧЕСКОГО И МИНМАКС
                  log-ЧЕБЫШЕВСКОГО МЕТОДА АППРОКСИМАЦИИ

   Рассмотрим пример из статьи [12]. В ней исследуется задача выбора руководителя
проекта в области программирования. Кандидаты попарно оцениваются по K = 4 при-
знакам: 1) персональные качества, 2) академические достижения, 3) опыт работы в ко-
манде, 4) уровень программирования. Матрица парных сравнений для метода Коггера
и Ю имеет вид:                                 
                                                           1        4           3       7
                                                         0                     1
                                                                    1           3       3
                                                      C =                                .
                                                                                         
                                                         0         0           1       5
                                                           0        0           0       1
     N = 4, то есть рассмотрены кандидаты A 1 , A 2 , A 3 , A 4 , результаты оценки которых по
каждому признаку отражают следующие матрицы парных сравнений:
                                                                                                                                          
             1   2    3    4            1          2     3    4            1                   2    2        3            1         3   2      3
           0    1    3    2         0           1     2    3         0                    1    2        3         0          1   2      4
      A1 =                1  , A2 =                           , A3 =                                       , A4 =                         .
                                                                                                                                          
           0    0    1    3
                                     0           0     1    2         0                    0    1        2         0          0   1      1
             0   0    0    1            0          0     0    1            0                   0    0        1            0         0   0      1

   Необходимо рассчитать веса признаков w матрицы C, а также веса альтернатив по
признакам ωi по матрицам A 1 , A 2 , A 3 , A 4 . Строится делящая матрица D −1 :
                                                              1                           
                                                                        0           0    0
                                                              04       1
                                                                                    0    0
                                                       −1               3
                                                  D         =                             .
                                                                                          
                                                                                    1
                                                             0         0           2    0
                                                               0        0           0    1
   Она будет идентичной для всех МПС в данной задаче, так как все они имеют одинако-
вый размер. После для каждого объекта (признаков или альтернатив по признаку) про-
исходит умножение делящей матрицы D −1 на МПС объекта:
                     1             3   7
                                                              1       1           3
                                                                                                                  1        1      3
                                                                                                                                          
                      4    1        4   4                       4       2           4     1                            4     2      4   1
                  0       1        1                                   1                  2                                1      2
                                        1               0                         1                    0                             1
          D −1C =         3        9       , D −1
                                                   A   =                3                  3
                                                                                           1,D −1 A 2 =                    3      3     ,
                                                                                                                                      
                                    1   5            1                              1                                               1
                  0       0                             0             0                                0 0                           1
                                                        
                                    2   2                                           2      6                                        2
                                                                                            
                    0      0        0   1                  0            0           0     1                0 0                      0   1
                                          1 1 1 3                                         1 3 1 3
                                          04     2
                                                  1
                                                         2
                                                         2
                                                              2
                                                              1            04                          4
                                                                                                         1
                                                                                                               2
                                                                                                               2
                                                                                                                   4
                                                                                                                   4
                               −1                 3      3           −1                                  3     3   3
                           D        A3 =                        , D A4 =                                        1.
                                                                         
                                                         1                                                     1
                                         0       0      2    1           0                            0     2   2
                                                                                                                     
                                           0      0      0    1              0                           0     0   1
   Далее для каждой матрицы создается вектор a, элементами которого являются суммы
каждой строки полученного произведения:
                           15                  10                10                           11                    11 
                           4                      4                         4                        4
                         13        2            2            2             47 
                        9
                 aC   =  ,  a A1 =  4  , a A2 =  3  , a A3 =  3  , a A4 =  3  .
                                                                             
                          3        6            2            2            1
                           1           1              1              1              1


34                                                © КОМПЬЮТЕРНЫЕ ИНСТРУМЕНТЫ В ОБРАЗОВАНИИ. №4, 2024 г.
               Метод Коггера и Ю: открытая компьютерная реализация и решение задач ранжирования


     Затем необходимо умножить произведения D −1 M на вектор a для получения весов:
                                                                                                  
                       6, 3819                               3, 125                              3, 75
                      1, 8148                             2                                2, 666
       D −1C aC = w =            , D −1 A 1 a A 1 = ω1 =           , D −1 A 2 a A 2 = ω2 =        ,
                                                                                                  
                       4                                  0, 5                              1, 75 
                           1                                    1                                  1
                                                                                     
                                            3, 125                              3, 75
                                           2                                2, 666
                    D −1 A 3 a A 3 = ω3 =           , D −1 A 4 a A 4 = ω4 =          .
                                                                                     
                                           0, 5                              1, 75 
                                               1                                   1
    После этого все веса нормализуются по формуле (3) для выполнения условия
Pn
 i =1 w i = 1. Далее рассчитываются оценки по формуле (5):
                                                            
                                                     0, 4247
                                                   0, 3072
                                              ωw =          .
                                                            
                                                   0, 1348
                                                     0, 1330
     В статье [5] провели расчет несколькими способами.
                                                                                                            ¢T
     С помощью метода Саати получаются оценки (ωw)T = 0, 4535; 0, 2767; 0, 1304; 0, 1394 .
                                                                           ¡

     С помощью метода взвешенных геометрических средних получаются оценки
                                          ¢T
(ωw)T = 2, 1037; 1, 3139; 0, 5761; 0, 6280 .
       ¡

     Метод log-Чебышевской аппроксимации [5,24-26] дал результат min = (1; 0,4262;
                                                               ¢T
0,1991; 0,3568)T и max = 1; 0, 8371; 0, 2336; 0, 4185 .
                             ¡

    Видно, что оценки приоритета 3 и 4 альтернатив по методу Коггера и Ю почти одина-
ковые и можно говорить об эквивалентности данных альтернатив по предпочтению, так
как различие приоритетов альтернатив измеряется одной тысячной. Схожий результат
получается МАИ, однако их ранги меняются местами. В двух оставшихся методах ран-
жирование альтернатив аналогично МАИ, однако различимость по значениям приори-
тетов больше. Это может быть полезным, если каждому объекту нужно сопоставить от-
дельный ранг.

                     10. СРАВНЕНИЕ РЕЗУЛЬТАТОВ МЕТОДА КОГГЕРА И Ю
                    С РЕШЕНИЕМ МАИ И ТЕОРИИ ВАЖНОСТИ КРИТЕРИЕВ

   Рассмотрим статью [17], где доказана некорректность метода аналитической иерар-
хии Саати. Берется задача с двумя равноважными признаками, для них строится матри-
ца парных сравнений:                     µ   ¶
                                                           1 1
                                                  A=           .
                                                           0 1
   Матрицы парных сравнений, где на диагонали и выше нее единицы, а ниже нули,
в методе Коггера и Ю при любых размерах МПС дадут такой вектор весов, в котором все
                                   µ ¶
                                    0, 5
элементы равны. Для данной МПС w =       .
                                    0, 5
   Далее задаются две параметризованные матрицы парных сравнений альтернатив по
каждому признаку:                             1
                                                         
                                  1    ab    a     1               1   a       1   b
                                              1    1 
                                 0     1     b   ab 
                                                                 0    1       a   ab 
                            F1 =                  1 ,     F2 =                     .
                                                                                    
                                 0     0    1    a
                                                                0    0       1   b
                                  0     0    0     1               0   0       0    1

АЛГОРИТМИЧЕСКАЯ МАТЕМАТИКА И МАТЕМАТИЧЕСКОЕ МОДЕЛИРОВАНИЕ                                                   35
Пархоменко В. А., Лазаренко А. А., Щукин А. В.


     При параметрах a = 3, b = 3 получаются следующие веса:
                                                                
                                        0, 6045            0, 1635
                                       0, 0606         0, 5420
                                  ω1 =          , ω2 =          ,
                                                                
                                       0, 1116         0, 2102
                                        0, 2232            0, 0841

     после чего рассчитаем методом Коггера и Ю итоговые оценки (таблица 4).

       Таблица 4. Итоговая оценка при различных параметрах a и b по методу Коггера и Ю

                                   a        3         3          4
                                   b        3         2          2
                                   x1    0,3840    0,3564     0,3768
                                   x2    0,3013    0,3051     0,3329
                                   x3    0,1609    0,1602     0,1327
                                   x4    0,1536    0,1781     0,1574


   Основная претензия к методу Саати [7] в том, при всех параметрах из таблицы 4 по-
лучается ранжировка x 2 ≻ x 1 ≻ x 4 ≻ x 3 , хотя при расчете по теории важности критериев
альтернатива x 1 должна быть лучше, чем x 2 (рис. 3).




      Рис. 3. Частичная упорядоченность вариантов по двум равноважным признакам [17]


   Исходя из таблицы 4 методом Коггера и Ю получена ранжировка x 1 ≻ x 2 ≻ x 3 ≻ x 4 .
Варианты x 3 и x 4 сменяют друг друга в полученной ранжировке в зависимости от пара-
метров, но если считать объекты эквивалентными с погрешностью ε = 0, 02, то данная
ранжировка более соответствует результатам, полученным с помощью теории важно-
сти критериев [17], хотя x 2 и x 4 здесь по-прежнему не равноважны, а x 3 и x 4 являются
сравнимыми и равноважными.
   Далее перейдем к описанию задачи принятия решений, составленной авторами.


     11. РЕШЕНИЕ ЗАДАЧИ РАНЖИРОВАНИЯ АЛГОРИТМОВ ГЕНЕРАЦИИ УРОВНЕЙ
             ДЛЯ КОМПЬЮТЕРНЫХ ИГР В ДВУХМЕРНОМ ПРОСТРАНСТВЕ

    Решение задачи ранжирования алгоритмов генерации уровней для компьютерных
игр проведено с целью выбора алгоритмов-кандидатов для дальнейших улучшений дан-
ных алгоритмов.
    Составим таблицу 5 с оценкой альтернатив по критериям, а также укажем в ней на-
правление оптимизации. Признаки: 1) повторяемость (количество паттернов в уровне),
2) управляемость (количество параметров, которые могут управлять алгоритмом),
3) удобство использования (как много усилий должен приложить пользователь, чтобы
получить желаемую карту), порядковая шкала, 4) сложность реализации (количество


36                                      © КОМПЬЮТЕРНЫЕ ИНСТРУМЕНТЫ В ОБРАЗОВАНИИ. №4, 2024 г.
                      Метод Коггера и Ю: открытая компьютерная реализация и решение задач ранжирования


используемых библиотек, концептуальная сложность алгоритмов), порядковая шка-
ла. Значения альтернатив представлены в таблице 5, где g 1 — IORand [21], g 2 — GB
WFC [22], g 3 — PBDG [23], g 4 — WASPAS [24], g 5 — PCGQD [25], g 6 — RBCAA [26], g 7 —
PSOCG [27]. Стрелки ↑ и ↓ означают, соответственно, максимизируется или минимизиру-
ется признак. В зависимости от этого будет производиться нормализация в соответствие
с формулами (3) или (4).

                  Таблица 5. Оценка алгоритмов процедурной генерации игровых уровней


         N        Повторяемость ↓                        Управляемость ↑                      Удобство                  Сложность
                                                                                           использования ↑             реализации ↓
       g1                      35                                  4                                 3                          3
       g2                      20                                  4                                 3                          2
       g3                      72                                  3                                 1                          1
       g4                      24                                  3                                 2                          1
       g5                      33                                  2                                 2                          2
       g6                      40                                  1                                 3                          1
       g7                      55                                  1                                 2                          3


   Важность признаков задается экспертом: (10, 8, 6, 5). Все матрицы парных сравнений
строятся по алгоритму создания МПС при отсутствии транзитивности:
                                                                                  35       35   35       35   35   35 
                                                                          1
                                                                         
                                                                                  20       72   24       33   40   55
                                                                         0                20   20       20    1   20 
                                           10      10     1
                                                                                 1        72   24       33    2   55 
                                   1         8       6     2
                                                                         
                                                                         0                              72   72   72 
                                 0                  8     8                     0        1    3        33   40   55 
                                            1        6     5
                                                                         
                                                                                                         24   24   24 
                              S =                         6,     S 1 = 0       0        0    1                  55  ,
                                                                        
                                 0         0       1                                                    33   40
                                                           5
                                                                         
                                                                         0                                   33   33 
                                                                                  0        0    0        1
                                                             
                                                                                                              40   55 
                                                                                                                      
                                   0        0       0      1             
                                                                         0                                        40 
                                                                                  0        0    0        0    1    55
                                                                          0       0        0    0        0    0    1
                      4   4                                                   3        3        3
        1     1                 2       4   4             1         1   3                   1                   1 32        3   3   3
                                                                                                                                        3   1
                                                                                                                                            
                      3   3                                                   2        2        2                                   2
      0              4   4                                                   3        3        3                                          2
             1       3   3     2       4   4
                                                        0
                                                                   1   3     2        2    1   2
                                                                                                               0 1
                                                                                                                           2   2   1   2   3
      0                        3                                             1        1    1   1                                  1       1
             0       1   1     2       3   3
                                                        0
                                                                   0   1     2        2    3   2
                                                                                                               0 0
                                                                                                                           1   1   2   1   3
                                3                                                           2                                       1       1
S 2 = 0      0       0   1             3   3  , S 3 = 0          0   0     1        1        1 ,     S 4 = 0 0         0   1       1       .
                                                                                                           
                                2                                                           3                                       2       3
      
      0
                                                                                          2                                             2
              0       0   0     1       2   2          0          0   0     0        1    3   1             0 0         0   0   1   2   3
                                                                                                                                              
                                                                                                3                                          1
                                                                                                           
      0      0       0   0     0       1   1          0          0   0     0        0    1                  0 0         0   0   0   1
                                                                                                2                                           3
        0     0       0   0     0       0   1             0         0   0     0        0    0   1                0 0        0   0   0   0   1

   Для упрощения расчетов можно не создавать делящую матрицу D −1 , а поделить стро-
ки матриц согласно алгоритму произведения делящей матрицы на матрицу парных срав-
нений. Из произведения делящей матрицы на МПС получаются векторы сумм:

                                                1, 038           2, 0952              1, 5                2
                                                                                                      
                                            0, 5968         2, 2777          1, 5833         1, 4444
                  1, 4791                     
                                              1, 8581
                                                               
                                                                 1, 9 
                                                                                         
                                                                                   0, 5666
                                                                                                            
                                                                                                     0, 7666
                1, 3111                                                                             
             a =         ,            a 1 = 0, 6909 , a 2 =  2, 125  , a 3 = 0, 9166 , a 4 = 0, 7083 .
                                                                                                    
                 1, 1                                                                               
                                              0, 8083         1, 6666          0, 8888         1, 2222
                      1                       
                                              0, 8636
                                                               
                                                                 1 
                                                                                         
                                                                                    1, 25 
                                                                                                            
                                                                                                     0, 6666
                                                   1                 1                  1                 1

АЛГОРИТМИЧЕСКАЯ МАТЕМАТИКА И МАТЕМАТИЧЕСКОЕ МОДЕЛИРОВАНИЕ                                                                                    37
Пархоменко В. А., Лазаренко А. А., Щукин А. В.


   С помощью данных векторов вычисляются соответственные веса, которые проходят
нормализацию (формула (2), затем (3) или (4)):


                                  0, 1409          0, 1977          0, 1927          0, 0100
                                                                                      
                              0, 2052        0, 2077        0, 1919        0, 1032
              0, 3250           
                                0, 0078
                                                
                                                 0, 1645
                                                                 
                                                                  0, 0628
                                                                                  
                                                                                   0, 1970
                                                                                             
            0, 2729                                                                 
         w =         ,   ω1 = 0, 1950 , ω2 = 0, 1744 , ω3 = 0, 1198 , ω4 = 0, 2023 .
                                                                                    
            0, 2150                                                                 
                                0, 1709        0, 1240        0, 1195        0, 1313
              0, 1870           
                                0, 1565
                                                
                                                 0, 0656
                                                                 
                                                                  0, 1811
                                                                                  
                                                                                   0, 2138
                                                                                             

                                    0, 1233        0, 0656         0, 1317          0, 1420

     После этого происходит расчет итоговой оценки по формуле (5): ωw = (0, 1431; 0, 1840;
0, 0978; 0, 1746; 0, 1397; 0, 1477; 0, 1129)T .
     Получена ранжировка g 2 ≻ g 4 ≻ g 6 ≻ g 1 ≻ g 5 ≻ g 7 ≻ g 3 . Данный пример показывает, как
с помощью одной таблицы с вариантами и оценки признаков получить оценку альтер-
натив. Также данный пример учитывает разное направление оптимизации признаков.
     Для сравнения эту же задачу решим в системе поддержки принятия решений
СВИРЬ [13–15] с помощью метода анализа иерархий. Получен вектор приоритетов объ-
ектов (0, 15; 0, 17; 0, 13; 0, 16; 0, 14; 0, 14; 0, 11)T , в результате чего получена ранжировка
g 2 ≻ g 4 ≻ g 1 ≻ g 5 ≻ g 6 ≻ g 3 ≻ g 7 . Видно, что по сравнению с методом Коггера и Ю часть
рейтинга, начиная с третьего места сильно меняется.
     Теперь можно воспользоваться системой поддержки принятия решений DASS [11, 16,
18], которая использует методы из теории важности критериев. Для начала необходимо
привести шкалы таблицы 5 к единой шкале, а также сделать их сонаправленными. Для
признака «повторяемость» берется четыре интервала: {[100; 75), [75; 50), [50; 25), [25; 0]}, по
которым признак загрубляется. В признаке «сложность разработки» числа 1 и 3 меняют
друг друга местами (таблица 6).

      Таблица 6. Оценка алгоритмов процедурной генерации игровых уровней в единой шкале


 N      Повторяемость       Управляемость        Удобство использования      Сложность реализации
 g1              3                    4                      3                         1
 g2              4                    4                      3                         2
 g3              2                    3                      1                         3
 g4              4                    3                      2                         3
 g5              3                    2                      2                         2
 g6              3                    1                      3                         3
 g7              2                    1                      2                         1


    Произведем расчет методом Коггера и Ю, а также с помощью DASS и СВИРЬ по этим
данным. В таблице 7 приведены значения оценок альтернатив методом Коггера и Ю,
DASS и СВИРЬ.
    Методом Коггера и Ю получена ранжировка g 2 ≻ g 4 ≻ g 6 ≡ g 1 ≻ g 5 ≻ g 3 ≻ g 7 . Прочерки
во второй колонке означают, что альтернативы были отброшены по Парето. Оставшие-
ся g 2 , g 4 , g 6 являются недоминируемыми. Если уточнять оценку встроенным средством
DASS (авторам статьи не удалось найти математическое описание «уточнения»), то по-
лучается ранжировка g 2 ≻ g 4 ≻ g 6 , что коррелирует с результатом, полученным методом


38                                        © КОМПЬЮТЕРНЫЕ ИНСТРУМЕНТЫ В ОБРАЗОВАНИИ. №4, 2024 г.
             Метод Коггера и Ю: открытая компьютерная реализация и решение задач ранжирования


Таблица 7. Значения приоритетов сущностей по методу Коггера и Ю, теории важности критериев,
рассчитанные в СППР DASS [16] и по МАИ в СППР СВИРЬ [13]


    G       Расчеты          Расчеты по теории важности        Расчеты по методу анализа
         по Коггеру и Ю       критериев с помощью DASS         иерархий с помощью СВИРЬ
   g1          0,15                        —                              0,1609
   g2          0,18                      0,657                            0,1888
   g3          0,12                        —                              0,1262
   g4          0,17                      0,248                            0,1720
   g5          0,13                        —                              0,1288
   g6          0,15                      0,094                            0,1379
   g7          0,10                        —                              0,0855



Коггера и Ю. Отметим, что расчет по методу Коггера и Ю в суженном пространстве по
Порето может также привести к большей различимости альтернатив по приоритетам.
     Видно, что ранжировки методом Коггера и Ю по исходной таблице и таблице в еди-
ной шкале почти полностью совпадают, что может косвенно означать, что построенная
единая порядковая шкала корректна. Методом анализа иерархий получена ранжировка
g 2 ≻ g 4 ≻ g 1 ≻ g 6 ≻ g 5 ≻ g 3 ≻ g 7 . Результат МАИ немного отклоняется от решений, получен-
ных методом Коггера и Ю, меняется приоритет первой и шестой альтернатив.
     Все три расчета подтверждают перспективность использования алгоритмов GB
WFC [22] — g 2 и WASPAS [24] — g 4 для дальнейшей оптимизации в рамках генерации
игровых уровней.

                                     12. ЗАКЛЮЧЕНИЕ

    В ходе исследования подробно проанализирован метод Коггера и Ю. Разработана соот-
ветствующая СППР с открытым исходным кодом [10], которая может быть использовано
в рамках принятия решений в образовательных и иных целях.
    Проведено пошаговое вычисление оценок альтернатив по статьям [12] и [17]. Выяв-
лено, что ранжировка методом Коггера и Ю может отличаться от метода Саати, метода
взвешенных геометрических средних и метода лог-Чебышевской аппроксимации [12].
Последние два метода показали более сильную различимость оценок приоритетов на
рассмотренном примере, измеримую десятыми и сотыми долями целого числа вместо
тысячных значений у методов Коггера и Ю и Саати. Последнее означает фактическую
эквивалентность альтернатив по рангам.
    Проведены расчёты рангов альтернатив на примере из статьи [17]. Выявлено, что ме-
тод Коггера и Ю показывает более согласованные результаты с теорией важности кри-
териев, дополнительно сужая множество Парето, но без таких противоречий, которые
указаны в [17] в рамках критики МАИ. На указанном примере это подтверждено с точно-
стью до двух сотых.
    В проведенном исследовании сформирована оригинальная задача ранжирования
альтернатив — алгоритмов генерации уровней для компьютерных игр в двухмерном
пространстве. Оно проведено с целью выбора алгоритмов-кандидатов для дальнейших
улучшений данных алгоритмов. В результате решения задачи результаты рейтингов, по-
лученных различными методами, показывают «уверенное» первое место у GB WFC [22],
а второе — у WASPAS [24]. Данные алгоритмы выбраны для дальнейших улучшений.


АЛГОРИТМИЧЕСКАЯ МАТЕМАТИКА И МАТЕМАТИЧЕСКОЕ МОДЕЛИРОВАНИЕ                                    39
Пархоменко В. А., Лазаренко А. А., Щукин А. В.


   В качестве дальнейших шагов авторы планируют проверить появившуюся в рамках
данного исследования гипотезу: снижение противоречий в решении методом Коггера
и Ю по сравнению с МАИ достигается, прежде всего, тем, что в методе расчета Коггера
и Ю по построению снижается противоречивость в матрице парных сравнений.


                                        Список литературы

 1. Krivulin N. Rating alternatives from pairwise comparisons by solving tropical optimization
    problems // Proc. of 2015 12th International Conference on Fuzzy Systems and Knowledge Discovery
    (FSKD). IEEE, 2015. P. 162–167. doi:10.1109/FSKD.2015.7381933
 2. Микони С. В. Теория принятия управленческих решений: учебное пособие. СПб.: Издательство
    «Лань», 2022. 384 с.
 3. Петровский А. Б. Теория принятия решений: учебник для ВУЗов. М.: Издательский центр «Ака-
    демия», 2009. 400 с.
 4. Подиновский В. В. Многокритериальные задачи принятия решений: теория и методы анализа:
    учебник для вузов. М.: Издательсво Юрайт, 2025. 486 с.
 5. Черноруцкий И. Г. Методы принятия решения [Электронный ресурс]: учебное пособие; Санкт-
    Петербургский государственный политехнический университет [Электронный ресурс]. СПб.,
    2012. URL: http://elib.spbstu.ru/dl/2358.pdf (дата обращения: 22.12.2024).
 6. Cogger K. O., Yu P. L. Eigenweight vectors and least-distance approximation for revealed preference
    in pairwise weight ratios // Journal of optimization theory and applications. 1985. Vol. 46. P. 483–491.
 7. Saaty T. L. A scaling method for priorities in hierarchical structures // Journal of mathematical
    psychology. 1977. Vol. 15, №. 3. P. 234–281.
 8. СППР Superdecisions [Электронный ресурс] URL: https://www.superdecisions.com/ (дата обраще-
    ния: 22.12.2024).
 9. Салимгареев И. А. AHP [Электронный ресурс]. URL: https://github.com/DM-app-tools/AHP (дата
    обращения: 22.12.2024).
10. Пархоменко В. А., Лазаренко А. А. Cистема поддержки ранжирования методом Коггера и Ю
    [Электронный ресурс]. URL: https://github.com/DM-app-tools/CoggerYuDecisionHelper (дата обра-
    щения: 22.12.2024).
11. Подиновский В. В., Подиновская О. В. О некорректности метода анализа иерархий // Проблемы
    управления. 2011. №. 1. С. 8–13.
12. Кривулин Н. К. и др. Решение многокритериальных задач оценки альтернатив на осно-
    ве парных сравнений // Компьютерные инструменты в образовании. 2024. №. 2. С. 5–29.
    doi:10.32603/2071-2340-2024-2-5-29
13. СППР СВИРЬ [Электронный ресурс]. URL: http://www.mcd-svir.ru/ (дата обращения: 22.12.2024).
14. Микони С. В. Система выбора и ранжирования «СВИРЬ» // Труды международного конгресса
    «Искусственный интеллект в XXI веке». Дивноморское 3–8.09.2001. М., 2001. Т. 1. С. 500–507.
15. Микони С. В. Бураков Д. П. Гарина М. И. Инструментальная система для выбора задач много-
    критериального выбора // Программные продукты и системы: научн. и научно-практич. изд.
    Тверь, 2009. № 4 (88). С. 6–9 .
16. СППР DASS [Электронный ресурс]. URL: http://mcodm.ru/soft/dass/ (дата обращения: 22.12.2024).
17. Подиновский В. В., Потапов М. А. Теоретические основы и системы поддержки принятия мно-
    гокритериальных решений // Материалы XXXIV Международной конференции «Информаци-
    онные технологии в науке, образовании, телекоммуникации и бизнесе» (20–30 мая 2007 г., Гур-
    зуф, Украина). Приложение к журналу «Открытое образование». 2007. С. 87–89.
18. Подиновский В. В. Анализ задач многокритериального выбора методами теории важности
    критериев при помощи компьютерных систем поддержки принятия решений // Известия Рос-
    сийской академии наук. Теория и системы управления. 2008. № 2. С. 64–68.
19. Соколова О. А., Черноруцкий И. Г. Программная реализация диалоговой системы выбора вари-
    антов на основе метода Коггера и Ю // Неделя науки СПбПУ. 2019. С. 64–67.
20. Инструмент для формализации Archimate [Электронный ресурс]. URL: https://www.
    archimatetool.com/ (дата обращения: 22.12.2024).
21. Moreno-Armendariz ˊ   M. A. et al. IORand: A Procedural Videogame Level Generator Based on a Hybrid
    PCG Algorithm // Applied Sciences. 2022. Vol. 12, №. 8. P. 3792.


40                                      © КОМПЬЮТЕРНЫЕ ИНСТРУМЕНТЫ В ОБРАЗОВАНИИ. №4, 2024 г.
                Метод Коггера и Ю: открытая компьютерная реализация и решение задач ранжирования


22. Kim H. et al. Graph based wave function collapse algorithm for procedural content generation in
    games // IEICE TRANSACTIONS on Information and Systems. 2020. Vol. 103, №. 8. P. 1901–1910.
23. Bagus Harisa A., Tai W. K. Pacing-based Procedural Dungeon Level Genera-tion: Alternating Level
    Creation to Meet Designer’s Expectations // International Journal of Computing and Digital Systems.
    2022. Vol. 12, №. 1. P. 401–416.
24. Petrovas A., Bausys R. Procedural video game scene generation by genetic and neutrosophic WASPAS
    algorithms // Applied Sciences. 2022. Vol. 12, №. 2. P. 772.
25. Gravina D. et al. Procedural content generation through quality diversity // 2019 IEEE Conference on
    Games (CoG). IEEE, 2019. P. 1–8.
26. Gellel A., Sweetser P. A hybrid approach to procedural generation of roguelike video game levels //
    Proc. of the 15th Int. Conf. on the Foundations of Digital Games. 2020. P. 1–10.
27. De Pontes R. G., Gomes H. M., Seabra I. S. R. Particle swarm optimization for procedural content
    generation in an endless platform game // Entertainment Computing. 2022. Vol. 43. P. 100496.


                 Поступила в редакцию 08.12.2024, окончательный вариант — 22.12.2024.



Пархоменко Владимир Андреевич, старший преподаватель Высшей школы программной
инженерии Института компьютерных технологий и кибербезопасности, СПбГПУ, Санкт-
Петербург, vladimir.parkhomenko@spbstu.ru
Лазаренко Артем Андреевич, студент магистратуры Высшей школы программной инжене-
рии Института компьютерных технологий и кибербезопасности, СПбГПУ, Санкт-Петербург,
lazarenko2.aa@edu.spbstu.ru
Щукин Александр Валентинович, канд. техн. наук, доцент Высшей школы программной
инженерии Института компьютерных технологий и кибербезопасности, СПбГПУ, Санкт-
Петербург, alexander.schukin@spbstu.ru




Computer tools in education, 2024
№ 4: 24–43
http://cte.eltech.ru
doi:10.32603/2071-2340-2024-4-24-43

                      Cogger and Yu Method:
 an Open Computer Implementation and Solution of Ranking Problems

        Parkhomenko V. A.1 , Senior Lecturer, vladimir.parkhomenko@spbstu.ru,
                                orcid.org/0000-0001-7757-377X
 Lazarenko A. A.1 , Magister, lazarenko2.aa@edu.spbstu.ru, orcid.org/0009-0005-1029-8095
       Schukin A. V.1 , Cand. Sc., Associate Professor, alexander.schukin@spbstu.ru,
                                orcid.org/0000-0002-9534-824X
                            1
                             Peter the Great St. Petersburg Polytechnic University,
                         29 Politekhnicheskaya str., 195251, Saint Petersburg, Russia

                                                  Abstract
           Cogger and Yu method for evaluation weights and ranking alternatives is considered.
           Based on this pairwise comparison method, an open source decision support system
           is developed. The architecture of the developed application is presented, unit tests are


АЛГОРИТМИЧЕСКАЯ МАТЕМАТИКА И МАТЕМАТИЧЕСКОЕ МОДЕЛИРОВАНИЕ                                             41
Пархоменко В. А., Лазаренко А. А., Щукин А. В.


           conducted, including examples from publications and specially generated test cases. An
           example by V.V. Podinovsky, illustrating the incorrectness of hierarchy analysis method,
           showed, from our point of view, an acceptable result by Cogger and Yu method. The
           experiment is conﬁrmed on a new original problem, showing the closeness of the results
           of Cogger and Yu method and criteria importance theory. The problem of ranking level
           generation algorithms for computer games in two-dimensional space is solved.
           Keywords: multicriteria decision-making problems, paired comparisons, Cogger and Yu
           method, criteria importance theory, DASS, SVIR.

           Citation: V. A. Parkhomenko, A. A. Lazarenko, and A. V. Schukin, “Cogger and Yu Method:
           an Open Computer Implementation and Solution of Ranking Problems,” Computer tools in
           education, no. 4, pp. 24–43, 2024 (in Russian); doi:10.32603/2071-2340-2024-4-24-43
           Acknowledgements: The paper authors are grateful to the DSS SVIR team of developers
           under the leadership of Professor S.V. Mikoni for providing the opportunity to solve
           problems in the system, as well as to the DSS DASS team of developers of under the
           leadership of Professor V.V. Podinovsky for making the system installer freely available.


                                                    References

 1. N. Krivulin, “Rating alternatives from pairwise comparisons by solving tropical optimization problems,” in Proc.
    of 2015 12th International Conference on Fuzzy Systems and Knowledge Discovery (FSKD). IEEE, 2015, pp. 162–167;
    doi:10.1109/FSKD.2015.7381933
 2. S. V. Mikoni, “Theory of Management Decision-Making: a textbook,” St. Petersburg, Russia: Lan Publishing House,
    2022 (in Russian).
 3. A. B. Petrovsky, Theory of Decision-Making: a textbook for universities, Moscow: Academy Publishing Center, 2009
    (in Russian).
 4. V. V. Podinovsky, Multicriteria Decision-Making Problems: Theory and Methods of Analysis: a textbook for universi-
    ties, Moscow: Yurait Publishing House, 2025 (in Russian).
 5. I. G. Chernorutsky, “Methods of Decision-Making,” in elib.spbstu.ru, Saint Petersburg State Polytechnical Universi-
    ty. St. Petersburg, 2012 (in Russian). [Online]. Available: http://elib.spbstu.ru/dl/2358.pdf.
 6. K. O. Cogger and P. L. Yu, “Eigenweight vectors and least-distance approximation for revealed preference in
    pairwise weight ratios,” Journal of optimization theory and applications, vol. 46, pp. 483–491, 1985.
 7. T. L. Saaty, “A scaling method for priorities in hierarchical structures,” Journal of mathematical psychology, vol.
    15, no. 3, pp. 234–281, 1977.
 8. Creative Decisions found., “Superdecisions DSS,” in in superdecisions.com, 2024. [Online]. Available: https://www.
    superdecisions.com/
 9. I. A. Salimgareev, “AHP,” in github.com, 2022. [Online]. Available: https://github.com/DM-app-tools/AHP
10. V. A. Parkhomenko and A. A. Lazarenko, “Ranking support system using the Cogger and Yu method,” in gi-
    thub.com, 2024. [Online]. Available: https://github.com/DM-app-tools/CoggerYuDecisionHelper
11. V. V. Podinovsky and O. V. Podinovskaya, “On the incorrectness of the method hierarchy process analysis,”
    Problems of Control Sciences, no. 1, pp. 8–13, 2011 (in Russian).
12. N. K. Krivulin et al., “Solution of multicriteria problems of alternatives evaluation based on paired comparisons,”
    Computer tools in education, no. 2, pp. 5–29, 2024 (in Russian); doi:10.32603/2071-2340-2024-2-5-29
13. D. P. Burakov and S. V. Mikoni, SVIR’ DSS, in mcd-svir.ru, 2009. [Online] (in Russian). Available:: http://www.
    mcd-svir.ru/
14. S. V. Mikoni, “SVIR’ selection and ranking system,” in Proc. of the international congress "Artiﬁcial Intelligence in
    the 21st century". Divnomorskoye 3-8.09.2001, vol. 1, pp. 500–507, 2001 (in Russian).
15. S. V. Mikoni, D. P. Burakov, and M. I. Garina, “Instrumental system for selecting multi-criteria choice problems,”
    Software products and systems: scientiﬁc and scientiﬁc-practical, no. 4 (88), pp. 6–9, 2009 (in Russian).
16. “The decision support system DASS,” in mcodm.ru, 2019. [Online]. Available: http://mcodm.ru/soft/dass/
17. V. V. Podinovsky and M. A. Potapov, “Theoretical foundations and systems for supporting multicriteria decisions,”
    in Proc. of the XXXIV International Conference "Information Technologies in Science, Education, Telecommunicati-
    ons and Business"(May 20-30, 2007, Gurzuf, Ukraine), Supplement to the journal "Open Education", pp. 87–89, 2007
    (in Russian).
18. V. V. Podinovsky, “Analysis of multicriteria choice problems by methods of the theory of criteria importance
    using computer systems for supporting decision making,” Bulletin of the Russian Academy of Sciences. Theory
    and Control Systems, no. 2, pp. 64–68, 2008 (in Russian).


42                                           © КОМПЬЮТЕРНЫЕ ИНСТРУМЕНТЫ В ОБРАЗОВАНИИ. №4, 2024 г.
                Метод Коггера и Ю: открытая компьютерная реализация и решение задач ранжирования


19. O. A. Sokolova and I. G. Chernorutsky, “Software implementation of a dialog system for selecting options based
    on the Cogger and Yu method,” SPbPU Science Week, pp. 64–67, 2019 (in Russian).
20. P. Beauvoir and J.-B. Sarrodie, “Archimate formalization tool,” in archimatetool.com, 2024. [Online]. Available:
    https://www.archimatetool.com/
21. M. A. Moreno-Armendariz   ˊ    et al., “IORand: A Procedural Videogame Level Generator Based on a Hybrid PCG
    Algorithm,” Applied Sciences, vol. 12, no. 8, pp. 3792, 2022.
22. H. Kim et al., “Graph based wave function collapse algorithm for procedural content generation in games,” IEICE
    TRANSACTIONS on Information and Sys-tems, vol. 103, no. 8, pp. 1901–1910, 2020.
23. A. Bagus Harisa and W. K. Tai, “Pacing-based Procedural Dungeon Level Genera-tion: Alternating Level Creation
    to Meet Designer’s Expectations,” International Journal of Computing and Digital Systems, vol. 12, no. 1, pp. 401–
    416, 2022.
24. A. Petrovas and R. Bausys, “Procedural video game scene generation by genetic and neutrosophic WASPAS algori-
    thms,” Applied Sciences, vol. 12, no. 2, p. 772, 2022.
25. Gravina D. et al., “Procedural content generation through quality diversity,” 2019 IEEE Conference on Games (CoG),
    pp. 1–8, 2019.
26. A. Gellel and P. Sweetser, “A hybrid approach to procedural generation of roguelike video game levels,” in Proc.
    of the 15th Int. Conf. on the Foundations of Digital Games, pp. 1–10, 2020.
27. R. G. De Pontes, H. M. Gomes, and I. S. R. Seabra, “Particle swarm optimization for procedural content generation
    in an endless platform game,” Entertainment Computing, vol. 43, pp. 100496, 2022.



                              Received 08-12-2024, the ﬁnal version — 22-12-2024.



Vladimir Parkhomenko, Senior Lecturer of Higher School of Software Engineering,
Institute of Computer Science and Cybersecurity, SPbPU, Saint Petersburg,
   vladimir.parkhomenko@spbstu.ru
Artem Lazarenko, Magister Student of Higher School of Software Engineering, Institute of
Computer Science and Cybersecurity, SPbPU, Saint Petersburg, lazarenko2.aa@edu.spbstu.ru
Alexander Schukin, Candidate of Sciences (Tech.), associate professor of Higher School of
Software Engineering, Institute of Computer Science and Cybersecurity, SPbPU, Saint Petersburg,
alexander.schukin@spbstu.ru




АЛГОРИТМИЧЕСКАЯ МАТЕМАТИКА И МАТЕМАТИЧЕСКОЕ МОДЕЛИРОВАНИЕ                                                         43
