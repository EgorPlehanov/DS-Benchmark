# Анализ результатов профилирования (интерпретация)

Источник: `results/profiling/processed_results/postprocessing_analysis/20260219_074831`.
Эталонная библиотека для сравнений: `our`.

## 1) Ключевые выводы

- **`our` — самый быстрый из библиотек с полным покрытием 4 этапов** (`step1..step4`):
  - `dstpy` медленнее на всех этапах (ускорение `our` относительно `dstpy`: ~`2.03x` на `step1`, `2.08x` на `step2`, `2.31x` на `step3`, `2.22x` на `step4`).
  - `dstz` особенно сильно проигрывает на `step2` и `step3` (ускорение `our`: ~`5.63x` и `8.71x` соответственно).
- **`pyds` нельзя корректно сравнить по полному пайплайну**, потому что он не поддерживает `step3` и `step4`. На `step1` он быстрее `our` (~`1.13x`), но на `step2` заметно медленнее (~`2.24x` в пользу `our`).
- По памяти **`our` — наиболее сбалансированный baseline**: у конкурентов чаще наблюдается перерасход в диапазоне `+5%..+40%` на поддерживаемых этапах, особенно у `dstz` на `step2`.

## 2) CPU: производительность по этапам

По среднему времени на повтор (`mean_per_repeat_ms`):

- `our`: `46.16`, `19.91`, `38.45`, `23.48` мс (`step1..step4`).
- `dstpy`: `93.46`, `41.39`, `88.91`, `52.02` мс — медленнее `our` на каждом этапе.
- `dstz`: `70.97`, `112.05`, `334.88` мс на поддерживаемых этапах — выраженный провал на `step2/step3`.
- `pyds`: `40.89`, `44.55` мс на `step1/step2`; `step3/step4` отсутствуют.

Практически:
- Если нужен **полный 4-шаговый процесс**, `our` дает лучшее время end-to-end среди сопоставимых решений (`dstpy`, `dstz`).
- Если нужен только поднабор (`step1+step2`), у `pyds` есть локальное преимущество на `step1`, но уже на `step2` преимущество переходит к `our`.

## 3) Память: пиковое потребление

Сравнение по `mean_peak_mb`:

- `our`: `0.129`, `0.134`, `0.199`, `0.139` МБ.
- `dstpy`: выше baseline на `+4.8%`, `+17.8%`, `+7.9%`, `+10.9%`.
- `dstz`: выше baseline на `+9.6%`, `+40.0%`, `+9.0%` (поддерживаемые этапы).
- `pyds`: чуть лучше baseline на `step1` (`-3.4%`), но хуже на `step2` (`+15.5%`).

Вывод: по памяти `our` не имеет «пиковых аномалий» и остается стабильным ориентиром между этапами.

## 4) Узкие места по строкам кода (`our`)

Главные CPU-hotspots в `our` сосредоточены в `src/core/dempster_core.py`:

1. Проверка пересечения множеств в суммировании масс:
   - `line 43`: `subset.intersection(event_fs)` — крупнейший вклад на всех этапах.
2. Проверка включения подмножеств:
   - `line 38`: `subset.issubset(event_fs)` — второй по вкладу hotspot.
3. Вложенные циклы комбинирования BPA:
   - `line 60`, `line 50`, частично `line 113`.

Это типичный паттерн «много итераций + операции над `set/frozenset`». Основной резерв ускорения — уменьшение числа таких проверок или их стоимости.

## 5) Что оптимизировать в первую очередь

1. **Индексирование/кэш для запросов belief/plausibility** (`issubset`/`intersection`):
   - кэшировать преобразования `event -> frozenset` (частично уже есть),
   - кэшировать результаты для повторяющихся `event_fs` и/или шаблонов подмножеств,
   - рассмотреть предрасчет структуры индексов по фокальным элементам.
2. **Оптимизация двойных циклов комбинирования**:
   - ранние отсечения,
   - уплотнение представления гипотез,
   - сокращение количества временных объектов Python.
3. **Снизить аллокации в горячем пути**:
   - избегать лишних преобразований контейнеров в циклах,
   - аккуратно проверить, где создаются новые `frozenset` и dict-объекты.

## 6) Ограничения интерпретации

- **Неполное покрытие этапов у `pyds` и `dstz`** (`step3/step4`), поэтому интегральное сравнение «кто быстрее в целом» корректно только между библиотеками с одинаковой функциональностью.
- **Scalene-выгрузка пустая** (`sample_count=0`), поэтому выводы по line-hotspots основаны на line-profiler данных.
- Разброс времени заметный (высокий `std`), поэтому для финальных решений по оптимизации полезно дополнительно запускать micro-bench на выделенных функциях.

## 7) Графики

Ниже — графики из набора постобработки:

![CPU absolute heatmap](plots/cpu_absolute_heatmap.png)
![CPU relative heatmap](plots/cpu_relative_heatmap.png)
![CPU speedup grouped bar](plots/speedup_grouped_bar.png)
![Memory absolute heatmap](plots/memory_absolute_heatmap.png)
![Memory relative heatmap](plots/memory_relative_heatmap.png)
![Memory efficiency grouped bar](plots/memory_efficiency_grouped_bar.png)
![Line bottlenecks for selected library](plots/line_bottlenecks_library_sorted_by_line.png)
![Line timings by library](plots/line_timing_by_library_subplots.png)
